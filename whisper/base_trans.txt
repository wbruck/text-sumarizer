Welcome to the Real Python Podcast. This is episode 145. Would you like to practice your Python skills while building a challenging word game? Have you wanted to learn more about creating command line interfaces and how to make them colorful and interactive? This week on the show, Christopher Trudeau is here bringing another batch of Pycoders weekly articles and projects. We share a recent Real Python step-by-step project about creating a clone of Whirdle. In the project, you'll practice building a terminal application, validating user input, and refactoring code into functions. Christopher shares an article that compares the two popular testing tools, Knox and Tox. He discusses how each framework approaches test environment configuration and why the author leans toward using Knox's Python decorator-based format. We share several other articles and projects from the Python community, including a news update, trying out code and ideas quickly with the Python REPL, a pep about requiring virtual environments by default, a discussion about things learned in 20 years as a software engineer, a project for a spreadsheet GUI inside of JupyterLab notebooks, and adding C-style for loops to Python. This episode is brought to you by Anaconda. With more than 30 million users, Anaconda is the world's most popular data science platform, making tomorrow's innovations possible. All right, let's get started. The Real Python podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses about at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey Christopher, welcome back. Yeah, hello. I'm excited to dive in this week. Got some kind of fun things I'm intrigued about and thrilled to 
talk about. And it's a real mix of stuff. We have some news to start. Is that right? Yeah, for sure. First one is for you, Django programmers out there. There's a security fix that has been issued, bringing us to 4.1.6, 4.0.9 and 3.2.17. The fix addresses a potential denial of service attack through the use of corrupted except language headers. So go patch stuff. Yeah. Second bit of news is the Python Software Foundation is hiring a security developer in residence. This is a full-time position to help formalize the existing security practices and to contribute to the security of CPython and PIPI. So resumes are being accepted until March 3rd and there's an online forum where you can submit your CV. It does have a capture there. So a AI need not apply, I guess. Yeah. You know, GPDs taking all the jobs, might as well do the security stuff. Yeah, it's interesting who's funding that one there. Oh, who's that? I didn't notice that. It's called the Open SSF Alpha Omega Project has made this work possible. So the Open Software Security. Alpha Omega, that sounds like a bad villain from an 80s movie. Yeah, potentially. Alpha and Omega. Yes. All right. Yeah, the Open Software Security Foundation. Excellent. Yeah, great. Cool. And 
the final little thing here is it's Python Maintenance for at least time. So Python 311.2, 310.10 and 312, Alpha 5 are now available. So get them while they're hot. Yeah. Wow, moving fast. Yep. All right. Well, my first, I guess in this case, the Stan article, but a step-by-step project is a real Python 1 by Garana Hella, frequent guest on the show. I don't know if he's done many step-by-steps, but this one's great. I'm really excited about it. And it has a very low barrier to entry as far as like what you need to know to get in and play with it. And it's called Build a Whirlpool clone with Python and Rich. If you're not familiar with Whirlpool, I don't know where you've been. But it kind of, it's a word game created by Josh Wartle launched in October of 2021. Got so popular online, everybody's sharing screenshots of it everywhere. It got bought by the New York Times. And so this is sort of a clone of it. It's missing a couple of features, but it is a great way for you to practice your Python skills and create a command line interface kind of game that's rather fun and kind of challenging and something that you could definitely share with other people. I found this great. And it looks pretty through using the Rich Library that Willem McGougan has created. And I had not played with Rich very much up to now. And wow, it really does make a difference. It really showcases the kinds of things that you can kind of create this nice console and colorizing the output and so forth really can make quite the difference to making something look a little refreshed and kind of fun. You start out this whole project building a prototype just the idea of like, how can you guess a secret word and giving you feedback of like, 
what letters were correct or maybe they were in the word, but not in the right position or they weren't part of the word at all. And so you kind of build that sort of initial functionality and practice that. And then one of the key things you need 
to do is have a list of words for the game to randomly choose from. And you build this kind of cool parsing mechanism that can grab any text that you want and separate it into a word list for you. And so he gives some examples that you can go on to, who was that Google project Gutenberg? I haven't read the article, but is that what you're trying to say? Exactly. Yeah, it's totally project Gutenberg. You can grab like Alice in Wonderland or something like that. Something that's a public domain book and have it go through and you can grab from that text file or you could use the, if you want more interesting words, you could grab say the works of Shakespeare or what have you. It's not picky. It just needs to be a text file and then we'll go through and parse and find words in there. That's a neat little command line program that runs and then you learn a little bit about using all these different kind of functionalities as you go. As you're working in it, you get to practice with path lib to do that reading of text and pulling in that file. And you learn a little bit about text encoding. Probably the biggest shift in the article and step by step process is that he wants you to build this prototype and then take it to the next step of actually building it as functions and creating what's called like a main loop that you may have seen in a lot of other programs. So you kind of learn some of these best practices of doing that and then creating the independent functions. So it's a little more maintainable. Also allows it to be testable and you get to practice that with doc test inside of here also. It's just really thoroughly thought out and takes you step by step. It's playable game kind of all the way through. 
And then at step four, you're already kind of getting a chance to play around with Rich and getting the console printing functionality and its language it uses for sort of stylizing things. And then he added a set of things to kind of work on validating to make sure that these sort of edge cases you might run into like what happens if it tries to read the file but then it fails somehow and the word list is empty. How should it gracefully fail out of that? What types of words should it accept if it has any kind of weird punctuation or something like that? How to kind of clean that stuff out? So you get to practice all those kinds of techniques. The one thing that you don't get a chance to do and this kind of left is one of those like here's the next step that you could do is as someone's typing, you know, you can verify that it's at least in the case of the standard word clone that it's a five letter word that they've typed. You can verify if they've tried to type the same word 
again. It's too short or too long but in the case of like confirming it's an actual dictionary word is something that he kind of leaves for you to figure out on your own. And I think you've learned enough through going through this whole thing that you could probably figure it out inside of there. And I'm sure there's other solutions that you can kind of check into. But it's a nice set of next steps for you. The idea you could also turn it into like a topical thing. The idea that you could kind of point that at these different files. So you could kind of like gear the word set, depending on, you know, the purposes of what you're sharing. You could also create other kinds of video game types of things like a splash screen or intro screen or what have you as additional ideas for next steps. I just really dug this thing. It was a lot of fun. Again, there's not a big barrier entry. You don't need to be per se an intermediate developer because you get to practice all these things as you go. Very smoothly. You get to work with the command line, work with user input, organizing the code, testing all these kinds of nice functions. And so really enjoyed it. I was very excited to say this has been five months or more in the process of creation. And Gara and I just been working on lots of other different things. And so I'm excited to see it come out. Well, and I'm pretty sure I read that Sherlock Holmes is finally hit open domain this year. So I'm a nice little source file you can go and get your wads in on. Get some other fun words in there if you're interested. Yeah. What's your first one? This is an opinion piece by a gentleman named Heinrich Schlawenck entitled Why I Like Knox. The article is a comparison piece between talks and knocks and why Heinrich prefers the latter. Case both talks and knocks sound like nonsense words to you. They're testing tools. Talks has been around for a while and its main purpose is multi-environment testing. I use it with open 
source libraries, I typically write and test my code in the most recent version of Python. Then use talks to do backward compatibility testing against older versions of Python. So talks automatically creates and populates virtual environments for you for each setup you've defined in a config file. And then runs your tests suite in each one of those environments. So that's talks. Knox is essentially an alternative. It handles the same kinds of problems. And its main claim to fame is how you configure it. Instead of using a text-based config file, you write actual Python scripts. There you go. Heinrich's article starts out by praising talks. He explains that it's a great tool and he's glad that it's out there. He doesn't really want to 
say anything negative about it. But prefers how Knox handles certain things. But since the article is a comparing contrast format, it inevitably sort of has to tell you talks and you know, he was very conscious of not coming across as a negative kind of space. The big chunk of the article really is the difference between how you configure the two tools. Talks uses an I and I or any file format for you. Youngins out there, that's an old school kind of a tamo sort of thing. The Talks config has sections and key value pairs. And for example, you set a value named M-list to specify which Python environments you want to use and talks sees that and sets things up. By contrast, as I mentioned, Knox is approaches to write code instead of using a config file, you write Knox file.py. Inside you import Knox and use decorators to specify what environments run on which tests. This doesn't actually get embedded in your test suite. It actually wraps that. So a typical Knox function has two calls. Session.install as to what packages to install from what place. And usually you're using like a pie project short form in that like your test suite. And then session.run where you give it the command that actually does the running. So that's call Python's unit test or pie test or knows or whatever test run or you use. Hynax preference here is based on the idea that you're already a Python programmer. You don't have to learn, talks is any language. And an example he gives here is some of the dependency handling magic that talks does under the covers. Config files he's used in the past don't always work with the newest version. And in theory this shouldn't happen with Knox because you're in control. It's you know, it's your program. So as long as you haven't broken like you know a Python version, you should be good. Digging into this sort of at the heart of it is a difference in structural philosophy. So talks uses a subclassing model for sharing where you override attributes. Whereas Knox uses a function based approach. So if you're trying to reuse a setup say between your 3, 7, and 3, 8 environment in talks, you need to use special attributes. And he's part of what he talks about is the fact that this can get confusing and the names of the attributes are a little messy and all the rest of it. Whereas because in Knox, it's just code, you create some variables and you can pass those variables around and reuse them as you would do code reuse. He just finds it much more intuitive. There's a few more pieces of information in here that goes into the details. Knox has always been on my to-do list to check out. So this article kind of just reinforced that for me. Yeah. A forum mentioned on the show, Thea Flowers. It was very involved in Knox and creating it. And I hadn't really done a deep dive into both of them. But this is a great way to kind of compare and contrast and see what's going on in them. And I think if your head space is in Python all day long, that's like an easy to parse kind of thing. You can see what's happening very quickly. Yeah. Versus like again learning another Tom O'Leik or whatever, you know, or Yamol like I and I file. Like I can agree with that that it's like, okay, it looks like again, white space really matters here. And you know, making sure that you got that you might end up having to again create like these kind of templates. Whereas something that's much more parsable and checkable because it's Python and you're familiar with that kind of how to do that. I think it could be really useful. I'm a big fan of decorators. Now, so again, I can kind of tell how that's being used and kind of what's happening with it. So the nice comparison. Yeah, I use talks 
a lot, but I have fairly simple setups. A lot of the things that he talks about in the article, I sort of like, Oh, okay, I never tried to do that. I wouldn't I wouldn't even know how to. And and so because I always start it like I have fairly simple needs, I'm not, you know, I'm not building 100,000 line multi whatever. It's just, hey, go run the tests for this environment. I'm not sure how much difference knocks would make for me. But like, you know, he's got a, um, an example in here where, you know, he's running the coverage tests only on certain versions, like the oldest version and the newest version or something along those lines. Yeah. And if you're trying to do trickier stuff like that, it's next to impossible in talks. And this is really just, oh, I'll decorate that line with this and put in a little if statement and you're done. So, uh, so I think, uh, I think it knocks his advantage probably comes about if you start trying to do, uh, uh, more challenging, more interesting things in your test weeks. Yeah. And so I mean, the examples also are like, like you're saying, like the different environments might be the versions of Python or, um, potentially like other, depending what else is installed, potentially in 
that environment. Yeah. And like, I know one of the things that I do with talks, you end up creating like, so if I'm, if I'm testing one of my Django libraries, I need to test that in multiple versions of Django and in multiple versions of Python. 
So you've got this sort of matrix thing that's happening, uh, going on and talks takes care of that. There's ways of setting all that up, but it starts to feel you're stepping up to, hey, this is black magic. You set this variable and it does it for you. And if something goes wrong, I'm like, yeah, I don't know what it's doing. So whereas if it's code, it starts to become, I can debug this. I know this or I know how to read Python. Whereas the any file means going back to the documentation. 
So so it's an interesting approach. Yeah, you could have run a debugger on it. Potentially exactly. Exactly. Yeah. With nothing to install and nothing to configure, Anaconda notebooks is a lightweight, ready to code and fully loaded data science environment entirely in your browser for free. Spin up new projects with a click of a button with all the packages and files you need in one place with fast and persistent cloud storage, no matter what, wherever you go, your code goes, no matter your experience level, learn through hands-on experimentation and you'll be predicting the future with machine learning models in no time. Start coding with Anaconda entirely in the cloud on anaconda.cloud. My next topic is about a new PEP, PEP 704. If you're not familiar with PEPs, we talk about them often on the show, but if they're Python enhancement proposals. So this is a proposed change or addition to Python. It's titled Require Virtual Environments by default for package installers. And having listened to us in the past, you know that we are fans of virtual environments. In fact, that's one of the primary ways that the last thing we were just talking about is operating, is creating all these environments to do testing in. And we had a deep dive in talking about virtual environment workflows in episode 141, talking about Brett Canon's surveying of that sort of stuff and how people kind of use them and the different types that are out there. It's interesting because he's a sponsor on this. The author of the PEP is Pradian Kadom. We had talked about an article from him in our last episode. So some repeat people here. It was written or generated, created on January 16th. And so it's kind of been out there accepting people's thoughts. I'll include a link to the discussions on Python.org for PEP 704. And also include some other links to this. If again, you're not using virtual environments, you're a little kind of confused about them. We have a really good article on real Python about it, but also I'll include the Python packaging user guide about what they say to do. The motivation, well, let me start with the abstract. The PEP is recommending that package installers like PEP require a virtual environment by 
default on Python 3.13. You might say, oh, that's way in the future. It's like, based upon what you had said earlier, they're already on alpha 5 with 312. So it's really not that far out there. It's something that we would want to think about pretty early on because it's kind of a big change. And what I feel like would happen is if someone who's going to use PEP is on their system, say, an older Mac that has Python, Python 2 is a system thing and they just type Python and PEP install. It could potentially install directly into the system Python. And we've kind of went into deep discussions on this in the past. And in this case, it would halt and say, actually, you probably don't want to do that and then provide some guidance as to how to create a virtual environment at that point so that you're not potentially polluting your existing Python installation or your system installation and that you want it to be going into there. So there's some system sort of stuff that would have 
to be written in the PEP in order to kind of check for this. The motivation is for new users. Like I said, things will seemingly work correctly when you don't have a virtual environment and they're not being used until that they don't. And it also 
kind of creates this scope of mistakes since users need to remember to activate the virtual environment before running install or like PEP or configure those installers to air out. So it's kind of like saying, oops, okay, yeah, you're right. I need to activate my virtual environment as a reminder. And so it kind of dives into that a little bit further. I won't read every detail of it. If you haven't looked at PEPs before, this is a good guide. This is a fairly short one. It covers potential 
issues with backwards compatibility. In this case, it's saying it would be incompatible with workflows where users are using installers outside of virtual environments. That actually kind of brings up a big thing. I'll mention here in kind of the commentary that's been happening in the conversation behind the scenes. It doesn't have any security implications. And then I think a very interesting section that they have in the PEPs is this thing called how to teach this. The PEP requires that new users create and use a virtual environment to get started using Python packages. This is however best practices as demonstrated in the case they have the link then to how to create virtual environments, which is on the Python packaging user guide. There's a reference implementation how they want to do it and then a little section about how they would detect if an active virtual environment is there. But it's been a fairly hotly debated thing. I went into the discussion area and it's interesting. I would argue that just my cursory reviewing and looking through this thing is that it's kind of leaning negative. I feel like a lot of people in the community feel like they already have these solutions. And of course people that are on a 
Python discussion board, you know, something like Python.org obviously are more likely going to be longtime Python users. And so they already have probably solutions for this and so they may not feel like it's needed. And this is really a conversation geared toward total beginners or people that accidentally do this often. And so that's kind of something I think that could be injected in the conversation. Some people don't really like the idea of how it would be enforced or it being enforced at all. A common issue set that kind of came into the conversation later, like probably over the last 10, 12 days is the issue with PIP and Konda. Konda is another virtual environment slash installer for Python packaging. The unfriendliness, if you will, between PIP and Konda is has been there a long time. It's something that I dealt with back a long time ago. And it was one of these things that had to be enforced in house rules. Like, hey, we're using Konda. Please don't add additional things to your setup using PIP because we won't be able to kind of control that and kind of goes back and forth. And so it ends up being a bit of a bummer, like kind of situation of like how can you get those things to cooperate and what happens in that situation since it sounds like PIP 704 is geared around PIP itself and not Konda specifically. So that's something that I think they might have to think about in being dealt with. Of course, if you're installing directly from Konda, you would probably not see that message then. So I don't know. It's something that is interesting part of the conversation. What do you think of this? I like the idea. Yeah. I've blown off some toes myself by accidentally forgetting to activate my virtual environment every once in a while. So I like the idea. I do understand, though, that anytime you've got a breaking change, that it's going to make people uncomfortable. I don't know how often this kind of thing gets scripted. But if it did, that's the 
problem. As soon as you upgrade, now you've got to go and edit all your scripts to add a command line value or an environment variable or however, they get around it to say, yes, no, I really mean to do this. And that's there in the PEP, right? They're not saying you can't PIP install. It's just saying, you know, the default is, are you sure you really want to do that? And in fact, that might even be one solution, right? It's like, prompt me and say, hey, hey, I haven't detected a virtual environment. I can continue. Exactly. That might be one way of handling it, right? But even then, you're back to needing dash yes or whatever if first scripted versions. You know, to me, the, I don't want to just completely reopen that can of worms. 
We went at it in the previous episode. But to me, the condo stuff is a red herring. That has so many other things. It's an own environment. And everybody brings condo up as in, well, what about condon? Like, well, let condo exists. Nobody's saying 
condo. It is a thing. Condon is doing what? And so like, and I think, you know, how you end up in some of those kinds of conversations are, this PEP says installers. And so everyone sort of goes, well, how do we make condo do it? And maybe the answer is, no, not installers. Maybe it's just, you know, what PIP's going to behave this way, which comes with Python installed, which comes with Python, right? So start there and then go, hey, we recommend other installers also behave this way and leave it there, right? So yeah, I don't know, it's anytime you talk packaging or virtual environments or whatever, there's, there's some, there's some depth there, right? And there's features and things that I don't use. And so I can't really pretend to say, oh, well, it definitely has to be done this way. I understand that there's a whole bunch of edge cases that, that I'm basically ignorant of, right? So it's on the surface. I like the idea, but, you know, I, it wouldn't surprise me if it doesn't happen, and I would understand. Yeah. I think it is a good conversation to have. And we talk about this within real Python often, you know, like, how can we get people comfortable with starting with Python and so forth and best practices and 
it kind of is steering people in that direction. And so I think that part of it is good. I'm glad that again, peps are not and I'll be all kinds of things, you know, they can be accepted or not accepted or they can remain as a conversation point for quite a while as ideas, again, their proposals. So I've found that interesting. The last couple of peps we've talked about, I'm like, wait a second, this is like four weeks old and it's approved and it's in this spot. That's not what I'm used to. I'm used to like, hey, this has been in draft for years. So yeah, yeah, essentially the paths that they can travel. Yeah. Yeah. So what's your next article? This is a real Python article from Leo Donas spoke, Sauramos, and it's called the Python standard repel tri-out code and ideas quickly. And as a bit of a segue from what we were talking about, this is more aimed at folks who are new to Python. Simply, it's as an introduction to the repel. Yeah. You know, it's, I live in the repel. I'm in there mucking around all the time. Some of that might be because I don't use your standard IDE. I'm a VI guy. We'll get back to that a minute. Yeah. But so I find when I'm teaching, I often go to it. I'm like, here, you can play with it, you can 
try this out. And I frequently students who have done like their own self-taught thing haven't come across it and they're locked in their IDE. So I love, you know, I love the fact that this article exists. It's like, Hey, you've got this. See, you 
know, the beauty of an interpreted language is you can have this little interactive playground. So go play. Yeah. Like most of Leo Donas's articles, this is pretty comprehensive. If you're just getting started to Python, it teaches you why you might want to use the repel and how to get into it, including some of the command line options. We talked a couple episodes back, one that was relatively recent discovery for me, which is the dash eye, which allows you to run a script and then dumps you into the repel after it's executed, which is great for seeing the state and helping you debug. So he talks about that and a couple other command line pieces. Then he goes on to talk about how to do multi-line code segments and things like line continuation and how error handling is done. So essentially, the basics of how to use these kinds of environments. He then starts talking about the special variable underscore. This is one of those things that I always forget is there. I come across 
it and I'm like, Hey, I knew that, and I'd never remember that it's in here. This is a variable, a special variable in the repel that gets the value of the last statement executed. Say I'm testing a Django query and I forget to store the result in 
a variable. I just type the query out and then I'm like, Oh, crap, I gotta do that again and put it in a variable. Well, the last value got put in underscore. You can just go variable equals underscore. So it's a nice little shortcut. One of the challenges you run into with the built-in repel is that importing is done once. So if you import some code from a file and then change the file, re-importing doesn't work. There is a work around though. And this isn't so much a repel feature as a Python feature, but it's a good one to know if you're using the repel a lot. The import lib library has a function called reload and it takes a reference to a module, which then reloads it, which is a handy little thing to remember. Then the next couple sections in the article talk about how you write and edit and re-execute chunks of code and some info on how to get help and inspect the code you've written. This includes things like the keyboard shortcuts, most of which map to the EMAX standard. If you're old enough to know what an EMAX is, for the record, it's a full operating system that has the side effect of including an editor. Sorry, like I mentioned, I'm a vi guy and just had to get the jab in old grunt battles for the best of the win. If you're not new to the repel, the next couple of sections might still have stuff that are useful to you. The repel is actually configurable and it has more depth than I realized. You can set up an environment variable called Python startup and point that to a file and it will load and execute that script when the repel starts. A couple examples he used of doing this was that reload function that I just talked about. If you're using it a lot or something like pretty print that you're using a lot, you can stick this in this startup file and then it'll get run every time you run the repel. This was no more important. Exactly. You don't have to keep typing it over and over again. That was a handy little thing I hadn't come across before. The other thing near the end he talks about is you can actually integrate it with Rich. As you were talking about before, Rich is this command line text formatting kind of thing and you can pull it into your repel and make your errors and 
tracebacks colorized. Again, if you want to do that all the time, you could stick that inside of your startup. Finally, the article finishes off with a description of what's missing and what to do about it. Mr. Bailey here mentioned the B Python repel alternative in episode 141. This article talks about it and others giving you a quick overview of their features. If you're new to the repel, this is a great introduction. If me, it's kind of old hat, there's still some value in a quick skim. There's a few little gems in here that you might not be familiar with that could make your repel experience better. There's some really good stuff in there. He always is deep on the research. I'm excited to dig a little bit deeper into it because I 
was like, oh, yeah, I know this. He's like, well, wait, hold on. Go look through not the side of the right table of contents, but the expanded table of contents at the top of the article. You could see some things that you maybe are as familiar with or it could be areas for you to research. I find with, there's always value in some of these kinds of longer articles because like I said, with the underscore, there's things you know, but if you don't use often, you forget. I just came back from vacation recently. I've got a nice camera, but I don't use it often enough to always remember how to use it. I'm always like, I know I know I know I know I know it does this, but I don't remember how to do it. I find every once in a while, I'm back into the manual going, how do I do this? Where is that button? Which one is this? This article is the same thing. Even if you know it, if you're not using it frequently, the little items of, wait, oh, yeah, that's right. I can do this and it'll make my life easier. That's, that's, there's value in that. Yeah, totally. This week, I want to shine a spotlight on another real Python video course. If you worked in the language like Java or C++, then you're probably used to writing, getter and setter methods for every attribute in your classes. These methods allow you to access and mutate private attributes while maintaining encapsulation. In Python, things are different and this course covers the details. It's titled Getters and Setters 
in Python. It's based on a real Python tutorial by previous guest Leodonis Boso-Ramos. And in the course, Darren Jones takes you through how to write getter and setter methods in your classes, replace getter and setter methods with properties, explore other tools to replace getter and setter methods within Python and decide when, setter and getter methods can be the right tool for the job. To get the most out of this course, you should have the fundamentals of object oriented programming in 
Python under your belt. And we've got you covered there with OOP courses and a learning path ready to go. Real Python video courses are broken into easily consumable sections and where needed include code examples for the technique shown. All lessons have a transcript including closed captions. Check out the video course. You can find a link in the show notes or you can find it using the enhanced search tool on real python.com. So that gets us into our discussion this week. So this is based 
on a slightly older article, but it seemed kind of came up. I'm guessing in some discussion areas and that's how you kind of found it this week and included in pie coders. It's titled 20 things I've learned in my 20 years as a software engineer. It's by Justin etharidge and it's on a site for a company called Simple Thread and there's a team of developers and they have a really nice blog. Very pretty site actually. Can we read through their blog? You can see that they have lots of deep thoughts about different things. UX design, engineering, DevOps and so forth. This one really is kind of focusing on a lot of core concepts and opinions, but basically things that he feels like he's learned over the years. I don't have as long as a software engineer. We've mentioned that multiple times on here, but number one, I definitely agree with and I see that in my favorite engineers that are out there, but it's basically I still don't know very much. That's the trick with software is that 
or even technology is that it's constantly changing and growing and going in different directions. Or you look at one particular language, something like JavaScript as an example, and it's just constantly evolving and all the different front and frameworks and different things that are out there and not to be upset that you don't know at all because there's hardly any way to know everything that's out there and you're going to just need to specialize in what you can learn. But most importantly, be open, be a lifelong learner and that's why I took this job. Why I got the real Python gig in first place because I was learning Python and wanted to learn more and one of my favorite ways to learn is to teach as being a teacher, you end up having to really learn the thing thoroughly to be able to explain it in any ways to other people. And that's why I decided to do the podcast. I really wanted to meet other people and ask them questions and make sure that I'm, you know, do I got the 
concept correctly and if I repeat it back to them, are they saying exactly back to me to say that I'm getting the ideas and making sense of it and then I can share that with other people. So that's been a fun part of it. Well, yeah, and it's not just a software-specific thing either, right? Yeah. It's, you know, I used to spend a lot of time with folks with PhDs and, you know, from a distance, it's like, oh, wow, they have that and what are they, whatever, and what they've done is they've just become the world's foremost expert on this tiniest little slice of something, right? Yeah, very much so. And that's not a negative thing. It means they're an expert in that, but there's just so much information in the world. You're never going to read every book and even if you did, you're not going to remember every one of them. Yeah. So I think there's a, there's a humbleness that kind of needs to go with that, always wanting to learn sort of thing. Yeah. I think that's a big part of the questioning. He has another one and there will probably hit it, but just the idea of like not being afraid to ask questions, you know, it's like, that's fine. And that to me, yes, is way more impressive is that the person is willing to ask the questions, the group of people that just sit there and stare at you and you're like, I know they have questions. I can see it in their eyes. So yeah. Yeah. Well, and one of the things, I really liked how he started this blog as well, which is he says, you're about to read a blog post with a lot of advice without understanding context, advice is meaningless. Yeah. So he's even starting from this humble place of, hey, here are my thoughts. They may or may not apply to you. You know, and he spends a little time talking about his context being smaller teams, this shipping focus, productivity, sort of focus versus say, you know, more of a esoteric language focus or tool, whatever, right? And that shifts how you interact and how you think about these things, right? And of course, it changes the advice you would give. You know, it's my university I did co-op, which it's some places known as internships. And I think one of the strongest things I got out of that program was working at different kinds of companies so that I could see when I got to the real world, like, oh, yeah, that style isn't me, that style is right. And getting that context and fitting in how that helps us out things massively, you know, like to get an idea of it. Yes, I had quite the shock having been a musician and a person just taking all these different jobs and really coming from the service industry and retail and all these other kinds of things are interacting with the customer directly at all times. It was very, very different when I was switched into, you know, like banking or a law firm or these other kinds of places or even larger sort of corporate structures. And I was like, this is this normal? Like, how this is functioning and how we 
approach problems and the answer to that question is no, no, it's not. It's just how everybody does it. Yeah, it's a difference between us. So weird. Yeah, so I bet that would have been really helpful to see where they different size organizations 
that you looked at too. Yeah, I worked, I spent some time at tiny little places and I spent some time at some very large places. So it kind of helped out that my understanding of my preference for smaller places. But anyhow, so there's a couple of 
things in here that you hear older engineers talk about all the time, you know, the best code is no code. Don't reinvent the wheel. You know, personally, like my most productive days are the ones where I'm removing code, which reminds me of, you know, I don't see it as much now, but for a long time, the answer was, well, how productive are they account? How many lines of code they wrote? Okay. So I removed 200 to days. That mean I'm negatively productive for, you know, right? Yeah. Like, didn't we just go through that with our friend, space Karen? So yes, yeah. Yeah. And then the one of the other ones I kind of liked in here was every system eventually sucks, get over it. So on one of our internal chat channels recently and real Python, I've been sharing, I have discovered Dillon Beatty and he's a programmer who does musical parodies on YouTube, musical parodies on YouTube. And he has a song called The Big Re Write. And it's based on American Pie, the song, nothing movie. And this kind of made me think of that, right? Like eventually you'll get to a place where you end up with BitRot, right? Like it may be perfect now, but over time, as multiple people touch it, as the needs change, you know, it's going to get worse. And the better you are at sort of internalizing that and knowing when to muck around and when not to muck around, makes a big difference in your productivity. Yeah, cool. I liked some of these other ones that I hear this often from other developers who are talking to people that are still learning the basics or maybe they've already gotten into the intermediate realm. He calls it, sometimes you have to stop sharpening the saw and just start cutting. And I agree, like, yes, that's a true thing that I've seen people do as far as like getting a project started. They just spent so many times preparing everything possible and never got to building anything on their own. And that happens in sort of tutorial hell that people kind of end up being in. It's like, well, try it out. You know, like I like to try to steer people more into that realm. And I have the biggest problem myself of like get started, get started. And so I've actually been getting much, much deeper into circuit Python. And I have a whole bunch of projects that are ready to go for me to dive in really deeply now. And so I'm excited to stop sort of sharpening the saw. So, no, he also talks about the 10X developer and how it's a myth. And I fully agree with them on this. Right? I don't really believe in 10X coders. He calls it something different, but I do believe in negative productivity. And he reversed this as the point one X developer. There are people that suck value out of a team. And I don't mean people learning because you need to give folks time to do that and different people journey differently. But there are folks that just end up causing more problems than they're solving on the team. And so like Justin, I'm not in search of a 10X, but I definitely want to try to figure out in my hiring how to avoid those negative folks. And that ties to something else. He said, which I really agree with, which is interviews are almost worthless for telling you how good of a team member. Someone will be smart and knowledgeable is not a good indicator. Obviously, you want people who are smart and knowledgeable. But the anti-patterns, you know, unreliability, abusiveness, pompousness, none of that shows up in an interview. Right? And yeah, I get a real sense from his comments that he's very keen on teams that know how to work well together. And there's a huge productivity difference when that when that geling happens with a small team. And again, I think that's back to that sort of small 
versus the large organization. You know, if you've only got five or 10 folks, one or two negative contributors makes a huge difference when you've got a hundred thousand, you know, it's a bump in the road and it's nothing. Yeah, he actually went much deeper because that was like the common refrain in the comments at the bottom of this article. He wrote a separate whole like article on it. And what it kind of had to explain what he meant by it. And then he describes all these different types, which I thought was really a good read to. So I'll include a link for that. But he at the comment section of that, a person added this really kind of interesting idea, how having a person on your team that isn't necessarily like a 10 times programmer, but is able to help the other programmers within the organization and get their code ready. And he likened it to, I don't know if you've played video games where it's like a big multi-party kind of thing, something like, you know, destiny or world of work craft, whatever. And there's this term they have for it called a carry. And so it's a person that can help new people that are to, you know, joining this big event, this raid or whatever they've done it before. And they're willing to sort of shurper or guide or carry individuals who are not familiar with this sort of experience through that experience and their polite and kind and like helpful and willing to deal with the newness of this person and the dumb questions that they have and explaining, you know, the process over and over. And some people just love that. And if you can find a developer who likes to do that sort of thing to carry other people and help them, there's such a asset to your team, you know, like the idea of just literally building within. I know there's going to be individuals who want to close themselves off and not necessarily help others. And those are the ones that, you know, very often can be like you said, the negative forces on your team. Yeah, I would take somebody who's got strong mentoring skills and solid coding skills over your so-called superstars every day of the week. Part of it, I think, is, you know, this is always just an experience thing. Yeah. But the vast majority of people that I've bumped into who consider themselves superstars were also extremely difficult to work with. You know, when I've been managing teams and I think of the overall productivity of the organization, I would much rather a group of so-called B players who get along and are studied and work together than trying to herd the cats of, you know, the programmer you see in movies, right? That stays up all night to solve the problem. And then at four o'clock in the morning when they fall asleep on their keyboard, I'm the one who's getting paged because they didn't notice that they were too tired to keep working. Yeah, or, you know, potentially they get frustrated and they leave and then it's like the soul like paleontology, like research of like what did they create here? Yeah. Yeah. Lots of interesting stuff. I like the idea of software engineers should write regularly, the idea that having a blog or a journal or writing documentation, it makes you think about what you're creating separately and differently and it's, you know, a skill to kind of sort of sharpen that communication skill. I think that's kind of interesting. Yeah, I think that goes with the mentorship part two, right? Because, you know, that those are soft skills that we don't think of as, oh, programmer, must know the language, you know, must be analytical. Yes, they must, but it's also good for the team. Yeah. If they've got some of those soft skills like communication. Yeah. No, it's a really good guide for lots of things to look at and definitely good discussion points that I think could be brought up with the team and to think about. So, all right. Well, that gets us into projects. Maybe I'll go first. Sure. So mine is called Myto. It's spelled M-I-T-O and its subtitle is a spreadsheet inside your Jupyter Lab notebooks. It is kind of an interesting tool. Like I was very excited by playing around with this for people that are doing that transition that are interested in like my wife, she is like an Excel queen. She knows everything in Excel and can do everything inside of it. It's kind of amazing. And she often asks me, well, what is Python? I'm like, well, you know, I got 144 episodes to show you can listen to. But in the 
end, it's something where if somebody can be working with a tool that they're familiar with, we're kind of know what these guide posts are that they want to try to accomplish. And maybe are used to a graphical user interface kind of leading them into that. This could do that for somebody who wants to get into data science, wants to move from Excel and maybe get to the level of automation and other tools without having to learn some of the more cryptic Microsoft tools and languages that they 
develop for doing it and do it and something maybe slightly more readable like Python. So you start this by just, when do you install it and pip install it, you can get going inside of your virtual environment. And the minute you launch that first 
line, it opens up graphical user interface with like very familiar looking drop-down menus and so forth. And you say, all right, file. And I want to go ahead and import this file. And maybe it's a CSV file. And instantly it's a data frame with at the top of it, again, very graphical kind of stuff where you can just click on like filter icons. And then it'll open a sidebar that gives you all the options for how you want to filter it and change it. And meanwhile, it's filling in cells of the Jupyter notebook below it with all the Python code that's needed to do this. So you want to create a pivot table. Okay, well, what do you want to pivot this versus that? Again, you're clicking on drop-down menus to select those things. And meanwhile, it's writing the code for you as you create it. It's really slick. It includes links to things like Matt Potlib or Plotlib importing tools and pandas and all that stuff is kind of in there. I just think it might be a nice kind of in-between tool 
for teaching people and getting them excited about doing Python and maybe helping you understand a little bit how to structure your code to do that. A couple of things that I didn't like about it has kind of a weird marketing bent to it. As you open up the first thing, it is asking you for your email address, which I thought was, well, that's a little strange. It doesn't require you to write an account, but it is asking for your email address. And I get it, you know, open source needs to be 
funded and needs to have a way to keep going. If that is completely jarring to you, then maybe this might be something to skip, but that part was a little strange. Other than that, I think it could be a really useful tool for people getting started. I have given my email address to so many different marketing things that's been my new hobby on weekends as to unsubscribed to as many things as they can as they kind of come up. But I think Mightau might be a nice in-between tool for people interested in maybe moving from Excel and knowing how to do some of the things inside there and how to, in some ways, it's even easier than Excel, I think, from the way I was looking at the way the GUI is laid out in it. So something to check out. What's your project? My project this week is called Curse de Four. It's by Tishara Sudwani. I think I'm developing a theme with the projects that attract me. So similar to the infinite AI array project I described in episode 141, this one started as a 
random post on Twitter, sort of a bet you can't do it. So Python is a C family of languages, but one of the things that distinguishes it from its ancestor is the lack of a C style for loop. If you haven't done C before, the for loop mechanism there is based on like a counter rather than say a for in kind of statement, like we have in Python. The C for statement has three parts, an initializer, a comparator, and an incrementer. And these parts are separated by semicolons. So if I was going to loop 10 times, I would say four i equals zero semicolon i less than 10 semicolon i plus plus. And that would say, you know, it starts a very it declares initializes a variable i. It checks whether or not that i is less than 10. And then at the end of the loop it increments it. So Python's for loop is more like what is often called for in in other languages. And that's based on an iterator mechanism. So the challenge that Toshara rose to was trying to implement a C like loop in Python. And since I'm talking about it, you might guess that he succeeded with the word succeeded in in quotes. You can install cursed four or I prefer to pronounce it cursed it makes seems more appropriate. It's just curse as you are as ed dash f or if you want to play with this. His approach is rather clever. He used a context manager in order to take advantage of the blocks and text because everything in the block is what gets looped. The second challenge is getting the variables and comparisons to work properly. So in Python, if I say i is less than 10, Python's going to evaluate that. And of course, in C, it's trying to evaluate that each time it goes through the loop. So there's no equivalent. So what he does is he creates a custom class called var, which you use in the assignment portion of the loop and then takes advantage of the wall receptor operator. So instead of saying i equals zero like you would in C, you say i colon equals var and then pass in the zero to var. So that's pretty close to what the C style looks like. And the reason he does this is it solves the comparison and increment portions. So if I just do x is less than 10, Python tries to evaluate that. But because I'm doing it on the var object, what ends up happening is the the dunder comparison methods get triggered. And since this is a var object, i less than 10 invokes dunder less than and then he overloads that to change the state of the class, essentially controlling the loop. And then he does a similar thing with dunder add to solve the increment problem. And then the final bit, which was kind of tricky, is you want the actual context manager block to be looped over. He does this by getting really funky with the AST module. This is a parsing 
module. This is a Python parsing module built into Python. He uses the AST node transformer class to basically find instances of the person for and then muck with their blocks so that you can do the looping. After that, he actually talks about an alternative implementation using a custom codec instead, which was inspired by an equally evil library one that added brace brackets to Python. So the project's kind of just a neat little idea and something to play with. The article on the other hand is beautiful. More interesting than the project itself. He goes through in detail how he worked all this out. Some of his dead ends that he attempted, things that worked, things that didn't work. So it's a master class in doing some very questionable things. But you learn a whole bunch about some of the more esoteric corners of Python while doing it. And how he approached it and how he conquered the problem and the things that stopped him and what he had to step back and try again. So I had fun reading this. And it's really obvious from the article that he had a lot of fun building it. I just hope it doesn't end up as a dependency in any of the libraries that I have to interact with. I don't want to see this. Yeah. This is funny. Beautiful and brilliant. Just don't use it. Yeah. No, I, we've talked about context managers several times in the last couple of episodes. We've talked about abstract syntax trees. And so you're getting to see that in person, the special methods, like all this sort of stuff that is underlying a lot of fundamental Python and the dismodule, the disassemble and kind of look at what's happening there. So it's using all that stuff. So if you wanted to see someone kind of going through how and hitting their head against the wall on a variety of different things, this is a really neat right up of it. And yeah, it's fascinating. I, again, I wouldn't want to use it. But I get the process in there. And one of the reasons I love projects like this is their self-contained. So if you're trying to learn a little more about say how an AST is done or if you're trying to learn more about writing context managers or whatever, if you go read an article, you sort of get, oh, that's the example. But 
trying to find a project that uses it, whereas this is a small enough project and it basically it's using it and doing very little else. So it's nice and self-contained. So even if, so even if the purpose is a little weird, you know, it's in a digestible trunk and you can go off and read some Python and try and understand how, how some of this stuff works and then figure out how to apply it to your own projects. That, that style is how JavaScript does it too, right? Yeah. Honestly, Python is the, not duck, is the black sheep here. Most languages in the C family have something like this. And this is why in most languages, there is a four in or something similar to that. Yeah. And honestly, I think Python probably should have just called the for loop something like that so that people who were new to the language didn't go away to second because it changes your expectations. Yeah. Yeah. But, you know, you know, here's my advice to Guido that's 30 years too late. So there you go. 
Yeah. All right. Well, cool. Well, thanks for bringing all these articles and topics and discussion points. This has been fun. See you again in a couple of weeks. Talk to you soon. And don't forget, you can code in a fully loaded data science environment entirely in your browser for free with Anaconda notebooks. Start coding with Anaconda entirely in the cloud on anaconda.cloud. I want to thank Christopher Tudot for coming on the show again this week. And I want to thank you for listening to the Real Python podcast. Make sure that you click that follow button in your podcast player. And if you see a subscribe button somewhere, remember that the Real Python podcast is free. If you like the show, please leave us a review. You could find show notes with links to all the topics we spoke about inside your podcast player or at realpithon.com slash podcast. And while you're there, you can leave us a question or a topic idea. I've been your host, Christopher Paley. And look forward to 
talking to you soon.

real    20m32.541s
user    0m0.000s
sys     0m0.015s